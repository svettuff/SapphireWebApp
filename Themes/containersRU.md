## Контейнеры в C++: Основы использования и разбор самых популярных

Контейнеры в C++ — это структуры данных, которые позволяют хранить и организовывать наборы элементов. Они являются частью Стандартной библиотеки C++ (STL). Каждый контейнер имеет свои особенности и подходит для определённых задач.
Раньше для хранения данных мы использовали обычные массивы или сталкивались с трудностями при работе с динамическими массивами. Теперь же, благодаря современным инструментам, мы выходим на новый уровень: это не только удобнее, но и значительно эффективнее.

### Что такое контейнеры?

Контейнеры — это "коробки", где хранятся данные. Они:

- Позволяют добавлять, удалять и перебирать элементы.
- Предоставляют функции для управления данными.
- Используют итераторы для доступа к элементам.

### Виды контейнеров

**Последовательные контейнеры**

Элементы расположены в определённом порядке, как в массиве или списке.

- `std::vector` — динамический массив.
- `std::list` — двусвязный список.
- `std::deque` — двухсторонняя очередь.

**Ассоциативные контейнеры**

Элементы хранятся с использованием ключей, что упрощает поиск.

- `std::map` — пары ключ-значение.
- `std::set` — уникальные элементы.

**Контейнеры на основе хэша**

Ускоренный доступ к элементам с помощью хэш-функций.

- `std::unordered_map` — пары ключ-значение без сортировки.
- `std::unordered_set` — уникальные элементы без сортировки.

**Адаптеры контейнеров**

Это специальные контейнеры, созданные на основе других.

- `std::stack` — стек.
- `std::queue` — очередь.
- `std::priority_queue` — очередь с приоритетами.

### Основные контейнеры и их использование

**Пример:** `std::vector`
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4};

    numbers.push_back(5); // Добавляем элемент
    for (int num : numbers) {
       std::cout << num << " ";
    }
    std::cout << std::endl;

    numbers.pop_back(); // Удаляем последний элемент
    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}
```

Цикл `for` в данном случае — это **range-based for**, упрощённый способ перебора элементов контейнеров. Его удобно использовать, если нам нужно просто перебрать элементы, поскольку он делает код более лаконичным и читаемым.

**Пример:** `std::list`
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> numbers = {1, 2, 3, 4};

    numbers.push_front(0); // Добавляем в начало
    numbers.push_back(5);  // Добавляем в конец

    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}
```

**Пример:** `std::map`
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<std::string, int> phoneBook;

    phoneBook["Alice"] = 1234;
    phoneBook["Bob"] = 5678;

    for (auto& [name, number] : phoneBook) {
        std::cout << name << ": " << number << std::endl;
    }

    return 0;
}
```

### Когда использовать какой контейнер?

- `std::vector` - Динамическое добавление/удаление элементов, быстрый доступ по индексу.
- `std::deque` - Быстрое добавление/удаление в начале и конце.
- `std::array` - Размер известен на этапе компиляции.
- `std::set` - Уникальные элементы, сортировка важна.
- `std::unordered_set` - Уникальные элементы, скорость важнее, чем порядок.
- `std::map` - Ключ-значение, сортировка важна.
- `std::unordered_map` - Ключ-значение, важна скорость поиска.
- `std::list` - Частые вставки и удаления в середине.
- `std::stack` - Реализация стека (LIFO).
- `std::queue` - Реализация очереди (FIFO).

Выбор правильного контейнера — ключ к оптимальному и удобному коду. Советую детально изучить внутреннее строение каждого контейнера.