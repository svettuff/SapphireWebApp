## Динамическое выделение памяти в C++

Динамическое выделение памяти позволяет программам запрашивать и освобождать память во время выполнения. Это полезно, когда заранее неизвестен объём данных, который потребуется.

### Зачем нужно динамическое выделение памяти?

**Гибкость:**

Используется, когда размер данных неизвестен на этапе компиляции.
Например, создание массива, размер которого зависит от пользовательского ввода.

**Экономия памяти:**

Память выделяется только тогда, когда это необходимо, а не зарезервирована заранее.

**Работа с большими данными:**

Динамическая память может быть полезна для работы с крупными структурами данных, такими как массивы, деревья или графы.

**Продолжительное хранение данных:**

Переменные, созданные динамически, сохраняются в памяти до тех пор, пока вы их не освободите (в отличие от автоматических переменных, которые уничтожаются при выходе из области видимости).

### Операторы `new` и `new[]`

Оператор `new` используется для выделения памяти в куче (heap). Куча — это область памяти, которая управляется операционной системой. Он возвращает указатель на выделенную память.

**Синтаксис:**
```cpp
тип_данных *указатель = new тип_данных;
```

**Пример:**
```cpp
int *ptr = new int; // Выделяем память для одного целого числа
*ptr = 42;          // Присваиваем значение
cout << *ptr << endl; // Выводим значение
```

Оператор `new[]` используется для выделения памяти под массив.

**Пример:**
```cpp
int *arr = new int[5]; // Выделяем память для массива из 5 элементов

for (int i = 0; i < 5; i++) {
    arr[i] = i + 1; // Заполняем массив значениями
}

for (int i = 0; i < 5; i++) {
    std::cout << arr[i] << " "; // Выводим элементы массива
}

delete[] arr; // Освобождаем память
```

### Операторы `delete` и `delete[]`

`delete` используется для освобождения памяти, выделенной оператором `new`.

`delete[]` используется для освобождения памяти, выделенной оператором `new[]`.

**Пример:**
```cpp
int *ptr = new int;
*ptr = 100;
delete ptr; // Освобождаем память

int *arr = new int[10];
delete[] arr; // Освобождаем память для массива
```

### Особенности и осторожности

**Утечка памяти:**

Если вы забыли освободить память с помощью `delete` или `delete[]`, выделенная память останется занятой до завершения программы.

**Пример утечки памяти:**
```cpp
int *ptr = new int;
*ptr = 42;
// delete ptr; // Если забыть освободить память, произойдёт утечка
```

**Доступ к освобождённой памяти:**

После освобождения памяти указатель становится висячим (dangling pointer). Использование такого указателя приводит к неопределённому поведению.

**Пример:**
```cpp
int *ptr = new int;
delete ptr; // Освобождаем память
// std::cout << *ptr; // Ошибка: доступ к освобождённой памяти
```

**Неинициализированная память:**

Память, выделенная с помощью `new`, не инициализируется автоматически (кроме указателей на объекты). Нужно самостоятельно инициализировать переменные.

**Пример:**
```cpp
#include <iostream>

int main() {
int *ptr = new int; // Выделение памяти для одного целого числа

    std::cout << "Значение в неинициализированной памяти: " << *ptr << std::endl; // Выводит неопределённое значение

    delete ptr; // Освобождаем память
    return 0;
}
```

### Дополнительно

Используйте динамическую память, если:
Размер данных зависит от ввода пользователя.
Вы хотите экономно использовать ресурсы памяти.
Вы работаете с крупными структурами данных (например, динамические массивы, графы).

В современных версиях C++ рекомендуется использовать умные указатели (`std::unique_ptr`, `std::shared_ptr`) для управления динамической памятью. Они помогают избежать утечек памяти, автоматически освобождая выделенные ресурсы, когда они больше не нужны. Мы ещё подробнее рассмотрим эту тему в будущем.

Кроме того, существуют контейнеры стандартной библиотеки (например, `std::vector`), которые автоматически управляют памятью и позволяют динамически изменять свой размер при добавлении новых элементов. Это упрощает разработку и делает использование памяти более безопасным. Однако, чтобы лучше понять, как работают эти механизмы, важно сначала разобраться, как осуществляется управление памятью "под капотом".

### Задача

Описание задачи: Напишите программу, которая:
Запрашивает у пользователя размер массива.
Динамически выделяет память для массива указанного размера.
Запрашивает у пользователя элементы массива.
Выводит массив на экран.
Находит минимальный и максимальный элементы массива.
Освобождает выделенную память.