## Шаблоны функций в C++: Введение и применение

Шаблоны функций позволяют писать одну универсальную функцию, которая может работать с разными типами данных. Это особенно полезно для создания обобщённого кода, чтобы избежать дублирования.

### Зачем нужны шаблоны функций?

**Обобщённое программирование:** Вместо написания нескольких версий одной и той же функции для разных типов данных, можно использовать шаблон.

**Избежание дублирования кода:** Вы пишете логику один раз, а компилятор сам создаёт нужные версии функции для каждого типа данных.

**Повышение читаемости и удобства сопровождения:** Один универсальный код легче поддерживать, чем несколько специализированных.

### Создание шаблона функции

Шаблон функции создаётся с использованием ключевого слова `template`. 

**Cинтаксис:**
```cpp
template <typename T>
возвращаемый_тип имя_функции(параметры) {
    // Реализация
}
```

`typename T` или `class T`:
- `T` — это тип, который будет подставлен компилятором во время вызова функции.
- Можно использовать как `typename`, так и `class`, они идентичны в данном контексте.
- Компилятор автоматически определяет тип `T` на основе аргументов, переданных в функцию.

**Пример:** Обобщённая функция для сравнения

```cpp
#include <iostream>

// Шаблон функции
template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Максимум (int): " << getMax(10, 20) << std::endl;       // int
    std::cout << "Максимум (double): " << getMax(10.5, 20.7) << std::endl; // double
    std::cout << "Максимум (char): " << getMax('a', 'z') << std::endl;     // char

    return 0;
}
```

**Вывод:**
```cpp
Максимум (int): 20
Максимум (double): 20.7
Максимум (char): z
```

### Несколько параметров типа

Можно использовать несколько типов в одном шаблоне.

**Пример:** Функция для сравнения разных типов
```cpp
#include <iostream>

template <typename T1, typename T2>
void displaySum(T1 a, T2 b) {
    std::cout << "Сумма: " << a + b << std::endl;
}

int main() {
    displaySum(10, 20.5);   // int + double
    displaySum(5.5, 3);     // double + int
    displaySum(3, 7);       // int + int

    return 0;
}
```

**Вывод:**
```cpp
Сумма: 30.5
Сумма: 8.5
Сумма: 10
```

### Ограничения типов

Иногда нужно ограничить, какие типы данных могут использоваться в шаблоне. Для этого можно использовать понятие concepts (доступно в C++20) или другие приёмы, например, `std::enable_if`. Этого мы коснемся позже.

### Явная и неявная специализация шаблонов

**Неявная специализация:** Компилятор сам определяет тип `T` из аргументов функции.

**Явная специализация:** Вы можете указать тип вручную.

**Пример:**
```cpp
#include <iostream>

template <typename T>
T multiply(T a, T b) {
    return a * b;
}

int main() {
    std::cout << multiply(2, 3) << std::endl;          // Неявная специализация (int)
    std::cout << multiply<double>(2.5, 4.0) << std::endl; // Явная специализация (double)

    return 0;
}
```

### Ограничения и особенности

**Компилятор должен видеть определение шаблона:**
Шаблон функции должен быть виден компилятору во время компиляции (обычно помещается в .h файлы).

**Шаблон не сокращает машинный код:**
Компилятор создаёт отдельные версии функции для каждого типа, поэтому шаблоны не уменьшают размер кода.

**Подходит только для однородных данных:**
Если требуется работать с разными типами в одной функции, нужно использовать несколько параметров типа.

### Задача

- Реализовать шаблон функции `findMax`, которая:
    - Принимает массив любого типа и его размер.
    - Возвращает максимальный элемент массива.